schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Ciphertext {
  id: Bytes!
  iv: Bytes!
  tag: Bytes!
  data: [Bytes!]!
}

input Ciphertext_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  iv: Bytes
  iv_not: Bytes
  iv_gt: Bytes
  iv_lt: Bytes
  iv_gte: Bytes
  iv_lte: Bytes
  iv_in: [Bytes!]
  iv_not_in: [Bytes!]
  iv_contains: Bytes
  iv_not_contains: Bytes
  tag: Bytes
  tag_not: Bytes
  tag_gt: Bytes
  tag_lt: Bytes
  tag_gte: Bytes
  tag_lte: Bytes
  tag_in: [Bytes!]
  tag_not_in: [Bytes!]
  tag_contains: Bytes
  tag_not_contains: Bytes
  data: [Bytes!]
  data_not: [Bytes!]
  data_contains: [Bytes!]
  data_contains_nocase: [Bytes!]
  data_not_contains: [Bytes!]
  data_not_contains_nocase: [Bytes!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Ciphertext_filter]
  or: [Ciphertext_filter]
}

enum Ciphertext_orderBy {
  id
  iv
  tag
  data
}

interface Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  batchStartTreePosition: Int!
  treePosition: Int!
  commitmentType: CommitmentType!
  hash: BigInt!
}

type CommitmentCiphertext {
  id: Bytes!
  ciphertext: Ciphertext!
  blindedSenderViewingKey: Bytes!
  blindedReceiverViewingKey: Bytes!
  annotationData: Bytes!
  memo: Bytes!
}

input CommitmentCiphertext_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  ciphertext: String
  ciphertext_not: String
  ciphertext_gt: String
  ciphertext_lt: String
  ciphertext_gte: String
  ciphertext_lte: String
  ciphertext_in: [String!]
  ciphertext_not_in: [String!]
  ciphertext_contains: String
  ciphertext_contains_nocase: String
  ciphertext_not_contains: String
  ciphertext_not_contains_nocase: String
  ciphertext_starts_with: String
  ciphertext_starts_with_nocase: String
  ciphertext_not_starts_with: String
  ciphertext_not_starts_with_nocase: String
  ciphertext_ends_with: String
  ciphertext_ends_with_nocase: String
  ciphertext_not_ends_with: String
  ciphertext_not_ends_with_nocase: String
  ciphertext_: Ciphertext_filter
  blindedSenderViewingKey: Bytes
  blindedSenderViewingKey_not: Bytes
  blindedSenderViewingKey_gt: Bytes
  blindedSenderViewingKey_lt: Bytes
  blindedSenderViewingKey_gte: Bytes
  blindedSenderViewingKey_lte: Bytes
  blindedSenderViewingKey_in: [Bytes!]
  blindedSenderViewingKey_not_in: [Bytes!]
  blindedSenderViewingKey_contains: Bytes
  blindedSenderViewingKey_not_contains: Bytes
  blindedReceiverViewingKey: Bytes
  blindedReceiverViewingKey_not: Bytes
  blindedReceiverViewingKey_gt: Bytes
  blindedReceiverViewingKey_lt: Bytes
  blindedReceiverViewingKey_gte: Bytes
  blindedReceiverViewingKey_lte: Bytes
  blindedReceiverViewingKey_in: [Bytes!]
  blindedReceiverViewingKey_not_in: [Bytes!]
  blindedReceiverViewingKey_contains: Bytes
  blindedReceiverViewingKey_not_contains: Bytes
  annotationData: Bytes
  annotationData_not: Bytes
  annotationData_gt: Bytes
  annotationData_lt: Bytes
  annotationData_gte: Bytes
  annotationData_lte: Bytes
  annotationData_in: [Bytes!]
  annotationData_not_in: [Bytes!]
  annotationData_contains: Bytes
  annotationData_not_contains: Bytes
  memo: Bytes
  memo_not: Bytes
  memo_gt: Bytes
  memo_lt: Bytes
  memo_gte: Bytes
  memo_lte: Bytes
  memo_in: [Bytes!]
  memo_not_in: [Bytes!]
  memo_contains: Bytes
  memo_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CommitmentCiphertext_filter]
  or: [CommitmentCiphertext_filter]
}

enum CommitmentCiphertext_orderBy {
  id
  ciphertext
  ciphertext__id
  ciphertext__iv
  ciphertext__tag
  blindedSenderViewingKey
  blindedReceiverViewingKey
  annotationData
  memo
}

type CommitmentPreimage {
  id: Bytes!
  npk: Bytes!
  token: Token!
  value: BigInt!
}

input CommitmentPreimage_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  npk: Bytes
  npk_not: Bytes
  npk_gt: Bytes
  npk_lt: Bytes
  npk_gte: Bytes
  npk_lte: Bytes
  npk_in: [Bytes!]
  npk_not_in: [Bytes!]
  npk_contains: Bytes
  npk_not_contains: Bytes
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CommitmentPreimage_filter]
  or: [CommitmentPreimage_filter]
}

enum CommitmentPreimage_orderBy {
  id
  npk
  token
  token__id
  token__tokenType
  token__tokenAddress
  token__tokenSubID
  value
}

enum CommitmentType {
  ShieldCommitment
  TransactCommitment
  LegacyGeneratedCommitment
  LegacyEncryptedCommitment
}

input Commitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  batchStartTreePosition: Int
  batchStartTreePosition_not: Int
  batchStartTreePosition_gt: Int
  batchStartTreePosition_lt: Int
  batchStartTreePosition_gte: Int
  batchStartTreePosition_lte: Int
  batchStartTreePosition_in: [Int!]
  batchStartTreePosition_not_in: [Int!]
  treePosition: Int
  treePosition_not: Int
  treePosition_gt: Int
  treePosition_lt: Int
  treePosition_gte: Int
  treePosition_lte: Int
  treePosition_in: [Int!]
  treePosition_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hash: BigInt
  hash_not: BigInt
  hash_gt: BigInt
  hash_lt: BigInt
  hash_gte: BigInt
  hash_lte: BigInt
  hash_in: [BigInt!]
  hash_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Commitment_filter]
  or: [Commitment_filter]
}

enum Commitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  batchStartTreePosition
  treePosition
  commitmentType
  hash
}

"""
8 bytes signed integer

"""
scalar Int8

type LegacyCommitmentCiphertext {
  id: Bytes!
  ciphertext: Ciphertext!
  ephemeralKeys: [Bytes!]!
  memo: [Bytes!]!
}

input LegacyCommitmentCiphertext_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  ciphertext: String
  ciphertext_not: String
  ciphertext_gt: String
  ciphertext_lt: String
  ciphertext_gte: String
  ciphertext_lte: String
  ciphertext_in: [String!]
  ciphertext_not_in: [String!]
  ciphertext_contains: String
  ciphertext_contains_nocase: String
  ciphertext_not_contains: String
  ciphertext_not_contains_nocase: String
  ciphertext_starts_with: String
  ciphertext_starts_with_nocase: String
  ciphertext_not_starts_with: String
  ciphertext_not_starts_with_nocase: String
  ciphertext_ends_with: String
  ciphertext_ends_with_nocase: String
  ciphertext_not_ends_with: String
  ciphertext_not_ends_with_nocase: String
  ciphertext_: Ciphertext_filter
  ephemeralKeys: [Bytes!]
  ephemeralKeys_not: [Bytes!]
  ephemeralKeys_contains: [Bytes!]
  ephemeralKeys_contains_nocase: [Bytes!]
  ephemeralKeys_not_contains: [Bytes!]
  ephemeralKeys_not_contains_nocase: [Bytes!]
  memo: [Bytes!]
  memo_not: [Bytes!]
  memo_contains: [Bytes!]
  memo_contains_nocase: [Bytes!]
  memo_not_contains: [Bytes!]
  memo_not_contains_nocase: [Bytes!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LegacyCommitmentCiphertext_filter]
  or: [LegacyCommitmentCiphertext_filter]
}

enum LegacyCommitmentCiphertext_orderBy {
  id
  ciphertext
  ciphertext__id
  ciphertext__iv
  ciphertext__tag
  ephemeralKeys
  memo
}

type LegacyEncryptedCommitment implements Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  batchStartTreePosition: Int!
  treePosition: Int!
  commitmentType: CommitmentType!
  hash: BigInt!
  ciphertext: LegacyCommitmentCiphertext!
}

input LegacyEncryptedCommitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  batchStartTreePosition: Int
  batchStartTreePosition_not: Int
  batchStartTreePosition_gt: Int
  batchStartTreePosition_lt: Int
  batchStartTreePosition_gte: Int
  batchStartTreePosition_lte: Int
  batchStartTreePosition_in: [Int!]
  batchStartTreePosition_not_in: [Int!]
  treePosition: Int
  treePosition_not: Int
  treePosition_gt: Int
  treePosition_lt: Int
  treePosition_gte: Int
  treePosition_lte: Int
  treePosition_in: [Int!]
  treePosition_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hash: BigInt
  hash_not: BigInt
  hash_gt: BigInt
  hash_lt: BigInt
  hash_gte: BigInt
  hash_lte: BigInt
  hash_in: [BigInt!]
  hash_not_in: [BigInt!]
  ciphertext: String
  ciphertext_not: String
  ciphertext_gt: String
  ciphertext_lt: String
  ciphertext_gte: String
  ciphertext_lte: String
  ciphertext_in: [String!]
  ciphertext_not_in: [String!]
  ciphertext_contains: String
  ciphertext_contains_nocase: String
  ciphertext_not_contains: String
  ciphertext_not_contains_nocase: String
  ciphertext_starts_with: String
  ciphertext_starts_with_nocase: String
  ciphertext_not_starts_with: String
  ciphertext_not_starts_with_nocase: String
  ciphertext_ends_with: String
  ciphertext_ends_with_nocase: String
  ciphertext_not_ends_with: String
  ciphertext_not_ends_with_nocase: String
  ciphertext_: LegacyCommitmentCiphertext_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LegacyEncryptedCommitment_filter]
  or: [LegacyEncryptedCommitment_filter]
}

enum LegacyEncryptedCommitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  batchStartTreePosition
  treePosition
  commitmentType
  hash
  ciphertext
  ciphertext__id
}

type LegacyGeneratedCommitment implements Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  batchStartTreePosition: Int!
  treePosition: Int!
  commitmentType: CommitmentType!
  hash: BigInt!
  preimage: CommitmentPreimage!
  encryptedRandom: [Bytes!]!
}

input LegacyGeneratedCommitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  batchStartTreePosition: Int
  batchStartTreePosition_not: Int
  batchStartTreePosition_gt: Int
  batchStartTreePosition_lt: Int
  batchStartTreePosition_gte: Int
  batchStartTreePosition_lte: Int
  batchStartTreePosition_in: [Int!]
  batchStartTreePosition_not_in: [Int!]
  treePosition: Int
  treePosition_not: Int
  treePosition_gt: Int
  treePosition_lt: Int
  treePosition_gte: Int
  treePosition_lte: Int
  treePosition_in: [Int!]
  treePosition_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hash: BigInt
  hash_not: BigInt
  hash_gt: BigInt
  hash_lt: BigInt
  hash_gte: BigInt
  hash_lte: BigInt
  hash_in: [BigInt!]
  hash_not_in: [BigInt!]
  preimage: String
  preimage_not: String
  preimage_gt: String
  preimage_lt: String
  preimage_gte: String
  preimage_lte: String
  preimage_in: [String!]
  preimage_not_in: [String!]
  preimage_contains: String
  preimage_contains_nocase: String
  preimage_not_contains: String
  preimage_not_contains_nocase: String
  preimage_starts_with: String
  preimage_starts_with_nocase: String
  preimage_not_starts_with: String
  preimage_not_starts_with_nocase: String
  preimage_ends_with: String
  preimage_ends_with_nocase: String
  preimage_not_ends_with: String
  preimage_not_ends_with_nocase: String
  preimage_: CommitmentPreimage_filter
  encryptedRandom: [Bytes!]
  encryptedRandom_not: [Bytes!]
  encryptedRandom_contains: [Bytes!]
  encryptedRandom_contains_nocase: [Bytes!]
  encryptedRandom_not_contains: [Bytes!]
  encryptedRandom_not_contains_nocase: [Bytes!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LegacyGeneratedCommitment_filter]
  or: [LegacyGeneratedCommitment_filter]
}

enum LegacyGeneratedCommitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  batchStartTreePosition
  treePosition
  commitmentType
  hash
  preimage
  preimage__id
  preimage__npk
  preimage__value
  encryptedRandom
}

type Nullifier {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  nullifier: Bytes!
}

input Nullifier_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  nullifier: Bytes
  nullifier_not: Bytes
  nullifier_gt: Bytes
  nullifier_lt: Bytes
  nullifier_gte: Bytes
  nullifier_lte: Bytes
  nullifier_in: [Bytes!]
  nullifier_not_in: [Bytes!]
  nullifier_contains: Bytes
  nullifier_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Nullifier_filter]
  or: [Nullifier_filter]
}

enum Nullifier_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  nullifier
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  commitmentPreimage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentPreimage
  commitmentPreimages(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentPreimage_orderBy
    orderDirection: OrderDirection
    where: CommitmentPreimage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentPreimage!]!
  ciphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Ciphertext
  ciphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: Ciphertext_orderBy
    orderDirection: OrderDirection
    where: Ciphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Ciphertext!]!
  legacyCommitmentCiphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LegacyCommitmentCiphertext
  legacyCommitmentCiphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: LegacyCommitmentCiphertext_orderBy
    orderDirection: OrderDirection
    where: LegacyCommitmentCiphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LegacyCommitmentCiphertext!]!
  commitmentCiphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentCiphertext
  commitmentCiphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentCiphertext_orderBy
    orderDirection: OrderDirection
    where: CommitmentCiphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentCiphertext!]!
  legacyGeneratedCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LegacyGeneratedCommitment
  legacyGeneratedCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: LegacyGeneratedCommitment_orderBy
    orderDirection: OrderDirection
    where: LegacyGeneratedCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LegacyGeneratedCommitment!]!
  legacyEncryptedCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LegacyEncryptedCommitment
  legacyEncryptedCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: LegacyEncryptedCommitment_orderBy
    orderDirection: OrderDirection
    where: LegacyEncryptedCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LegacyEncryptedCommitment!]!
  shieldCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShieldCommitment
  shieldCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: ShieldCommitment_orderBy
    orderDirection: OrderDirection
    where: ShieldCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ShieldCommitment!]!
  transactCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransactCommitment
  transactCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: TransactCommitment_orderBy
    orderDirection: OrderDirection
    where: TransactCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransactCommitment!]!
  unshield(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Unshield
  unshields(
    skip: Int = 0
    first: Int = 100
    orderBy: Unshield_orderBy
    orderDirection: OrderDirection
    where: Unshield_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Unshield!]!
  nullifier(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nullifier
  nullifiers(
    skip: Int = 0
    first: Int = 100
    orderBy: Nullifier_orderBy
    orderDirection: OrderDirection
    where: Nullifier_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Nullifier!]!
  commitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Commitment
  commitments(
    skip: Int = 0
    first: Int = 100
    orderBy: Commitment_orderBy
    orderDirection: OrderDirection
    where: Commitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Commitment!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type ShieldCommitment implements Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  batchStartTreePosition: Int!
  treePosition: Int!
  commitmentType: CommitmentType!
  hash: BigInt!
  preimage: CommitmentPreimage!
  encryptedBundle: [Bytes!]!
  shieldKey: Bytes!
  fee: BigInt
}

input ShieldCommitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  batchStartTreePosition: Int
  batchStartTreePosition_not: Int
  batchStartTreePosition_gt: Int
  batchStartTreePosition_lt: Int
  batchStartTreePosition_gte: Int
  batchStartTreePosition_lte: Int
  batchStartTreePosition_in: [Int!]
  batchStartTreePosition_not_in: [Int!]
  treePosition: Int
  treePosition_not: Int
  treePosition_gt: Int
  treePosition_lt: Int
  treePosition_gte: Int
  treePosition_lte: Int
  treePosition_in: [Int!]
  treePosition_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hash: BigInt
  hash_not: BigInt
  hash_gt: BigInt
  hash_lt: BigInt
  hash_gte: BigInt
  hash_lte: BigInt
  hash_in: [BigInt!]
  hash_not_in: [BigInt!]
  preimage: String
  preimage_not: String
  preimage_gt: String
  preimage_lt: String
  preimage_gte: String
  preimage_lte: String
  preimage_in: [String!]
  preimage_not_in: [String!]
  preimage_contains: String
  preimage_contains_nocase: String
  preimage_not_contains: String
  preimage_not_contains_nocase: String
  preimage_starts_with: String
  preimage_starts_with_nocase: String
  preimage_not_starts_with: String
  preimage_not_starts_with_nocase: String
  preimage_ends_with: String
  preimage_ends_with_nocase: String
  preimage_not_ends_with: String
  preimage_not_ends_with_nocase: String
  preimage_: CommitmentPreimage_filter
  encryptedBundle: [Bytes!]
  encryptedBundle_not: [Bytes!]
  encryptedBundle_contains: [Bytes!]
  encryptedBundle_contains_nocase: [Bytes!]
  encryptedBundle_not_contains: [Bytes!]
  encryptedBundle_not_contains_nocase: [Bytes!]
  shieldKey: Bytes
  shieldKey_not: Bytes
  shieldKey_gt: Bytes
  shieldKey_lt: Bytes
  shieldKey_gte: Bytes
  shieldKey_lte: Bytes
  shieldKey_in: [Bytes!]
  shieldKey_not_in: [Bytes!]
  shieldKey_contains: Bytes
  shieldKey_not_contains: Bytes
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ShieldCommitment_filter]
  or: [ShieldCommitment_filter]
}

enum ShieldCommitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  batchStartTreePosition
  treePosition
  commitmentType
  hash
  preimage
  preimage__id
  preimage__npk
  preimage__value
  encryptedBundle
  shieldKey
  fee
}

type Subscription {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  commitmentPreimage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentPreimage
  commitmentPreimages(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentPreimage_orderBy
    orderDirection: OrderDirection
    where: CommitmentPreimage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentPreimage!]!
  ciphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Ciphertext
  ciphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: Ciphertext_orderBy
    orderDirection: OrderDirection
    where: Ciphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Ciphertext!]!
  legacyCommitmentCiphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LegacyCommitmentCiphertext
  legacyCommitmentCiphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: LegacyCommitmentCiphertext_orderBy
    orderDirection: OrderDirection
    where: LegacyCommitmentCiphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LegacyCommitmentCiphertext!]!
  commitmentCiphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentCiphertext
  commitmentCiphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentCiphertext_orderBy
    orderDirection: OrderDirection
    where: CommitmentCiphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentCiphertext!]!
  legacyGeneratedCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LegacyGeneratedCommitment
  legacyGeneratedCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: LegacyGeneratedCommitment_orderBy
    orderDirection: OrderDirection
    where: LegacyGeneratedCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LegacyGeneratedCommitment!]!
  legacyEncryptedCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LegacyEncryptedCommitment
  legacyEncryptedCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: LegacyEncryptedCommitment_orderBy
    orderDirection: OrderDirection
    where: LegacyEncryptedCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LegacyEncryptedCommitment!]!
  shieldCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShieldCommitment
  shieldCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: ShieldCommitment_orderBy
    orderDirection: OrderDirection
    where: ShieldCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ShieldCommitment!]!
  transactCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransactCommitment
  transactCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: TransactCommitment_orderBy
    orderDirection: OrderDirection
    where: TransactCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransactCommitment!]!
  unshield(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Unshield
  unshields(
    skip: Int = 0
    first: Int = 100
    orderBy: Unshield_orderBy
    orderDirection: OrderDirection
    where: Unshield_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Unshield!]!
  nullifier(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nullifier
  nullifiers(
    skip: Int = 0
    first: Int = 100
    orderBy: Nullifier_orderBy
    orderDirection: OrderDirection
    where: Nullifier_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Nullifier!]!
  commitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Commitment
  commitments(
    skip: Int = 0
    first: Int = 100
    orderBy: Commitment_orderBy
    orderDirection: OrderDirection
    where: Commitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Commitment!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  id: Bytes!
  tokenType: TokenType!
  tokenAddress: Bytes!
  tokenSubID: Bytes!
}

enum TokenType {
  ERC20
  ERC721
  ERC1155
}

input Token_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  tokenType: TokenType
  tokenType_not: TokenType
  tokenType_in: [TokenType!]
  tokenType_not_in: [TokenType!]
  tokenAddress: Bytes
  tokenAddress_not: Bytes
  tokenAddress_gt: Bytes
  tokenAddress_lt: Bytes
  tokenAddress_gte: Bytes
  tokenAddress_lte: Bytes
  tokenAddress_in: [Bytes!]
  tokenAddress_not_in: [Bytes!]
  tokenAddress_contains: Bytes
  tokenAddress_not_contains: Bytes
  tokenSubID: Bytes
  tokenSubID_not: Bytes
  tokenSubID_gt: Bytes
  tokenSubID_lt: Bytes
  tokenSubID_gte: Bytes
  tokenSubID_lte: Bytes
  tokenSubID_in: [Bytes!]
  tokenSubID_not_in: [Bytes!]
  tokenSubID_contains: Bytes
  tokenSubID_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  tokenType
  tokenAddress
  tokenSubID
}

type TransactCommitment implements Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  batchStartTreePosition: Int!
  treePosition: Int!
  commitmentType: CommitmentType!
  hash: BigInt!
  ciphertext: CommitmentCiphertext!
}

input TransactCommitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  batchStartTreePosition: Int
  batchStartTreePosition_not: Int
  batchStartTreePosition_gt: Int
  batchStartTreePosition_lt: Int
  batchStartTreePosition_gte: Int
  batchStartTreePosition_lte: Int
  batchStartTreePosition_in: [Int!]
  batchStartTreePosition_not_in: [Int!]
  treePosition: Int
  treePosition_not: Int
  treePosition_gt: Int
  treePosition_lt: Int
  treePosition_gte: Int
  treePosition_lte: Int
  treePosition_in: [Int!]
  treePosition_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hash: BigInt
  hash_not: BigInt
  hash_gt: BigInt
  hash_lt: BigInt
  hash_gte: BigInt
  hash_lte: BigInt
  hash_in: [BigInt!]
  hash_not_in: [BigInt!]
  ciphertext: String
  ciphertext_not: String
  ciphertext_gt: String
  ciphertext_lt: String
  ciphertext_gte: String
  ciphertext_lte: String
  ciphertext_in: [String!]
  ciphertext_not_in: [String!]
  ciphertext_contains: String
  ciphertext_contains_nocase: String
  ciphertext_not_contains: String
  ciphertext_not_contains_nocase: String
  ciphertext_starts_with: String
  ciphertext_starts_with_nocase: String
  ciphertext_not_starts_with: String
  ciphertext_not_starts_with_nocase: String
  ciphertext_ends_with: String
  ciphertext_ends_with_nocase: String
  ciphertext_not_ends_with: String
  ciphertext_not_ends_with_nocase: String
  ciphertext_: CommitmentCiphertext_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TransactCommitment_filter]
  or: [TransactCommitment_filter]
}

enum TransactCommitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  batchStartTreePosition
  treePosition
  commitmentType
  hash
  ciphertext
  ciphertext__id
  ciphertext__blindedSenderViewingKey
  ciphertext__blindedReceiverViewingKey
  ciphertext__annotationData
  ciphertext__memo
}

type Unshield {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  to: Bytes!
  token: Token!
  amount: BigInt!
  fee: BigInt!
  eventLogIndex: BigInt!
}

input Unshield_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  eventLogIndex: BigInt
  eventLogIndex_not: BigInt
  eventLogIndex_gt: BigInt
  eventLogIndex_lt: BigInt
  eventLogIndex_gte: BigInt
  eventLogIndex_lte: BigInt
  eventLogIndex_in: [BigInt!]
  eventLogIndex_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Unshield_filter]
  or: [Unshield_filter]
}

enum Unshield_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  to
  token
  token__id
  token__tokenType
  token__tokenAddress
  token__tokenSubID
  amount
  fee
  eventLogIndex
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}