schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

interface Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  commitmentType: CommitmentType!
  hashes: [Bytes!]!
}

type CommitmentCiphertext {
  id: Bytes!
  ciphertext: Bytes!
  blindedSenderViewingKey: Bytes!
  blindedReceiverViewingKey: Bytes!
}

input CommitmentCiphertext_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  ciphertext: Bytes
  ciphertext_not: Bytes
  ciphertext_gt: Bytes
  ciphertext_lt: Bytes
  ciphertext_gte: Bytes
  ciphertext_lte: Bytes
  ciphertext_in: [Bytes!]
  ciphertext_not_in: [Bytes!]
  ciphertext_contains: Bytes
  ciphertext_not_contains: Bytes
  blindedSenderViewingKey: Bytes
  blindedSenderViewingKey_not: Bytes
  blindedSenderViewingKey_gt: Bytes
  blindedSenderViewingKey_lt: Bytes
  blindedSenderViewingKey_gte: Bytes
  blindedSenderViewingKey_lte: Bytes
  blindedSenderViewingKey_in: [Bytes!]
  blindedSenderViewingKey_not_in: [Bytes!]
  blindedSenderViewingKey_contains: Bytes
  blindedSenderViewingKey_not_contains: Bytes
  blindedReceiverViewingKey: Bytes
  blindedReceiverViewingKey_not: Bytes
  blindedReceiverViewingKey_gt: Bytes
  blindedReceiverViewingKey_lt: Bytes
  blindedReceiverViewingKey_gte: Bytes
  blindedReceiverViewingKey_lte: Bytes
  blindedReceiverViewingKey_in: [Bytes!]
  blindedReceiverViewingKey_not_in: [Bytes!]
  blindedReceiverViewingKey_contains: Bytes
  blindedReceiverViewingKey_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CommitmentCiphertext_filter]
  or: [CommitmentCiphertext_filter]
}

enum CommitmentCiphertext_orderBy {
  id
  ciphertext
  blindedSenderViewingKey
  blindedReceiverViewingKey
}

type CommitmentPreimage {
  id: Bytes!
  npk: Bytes!
  token: Token!
  value: BigInt!
}

input CommitmentPreimage_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  npk: Bytes
  npk_not: Bytes
  npk_gt: Bytes
  npk_lt: Bytes
  npk_gte: Bytes
  npk_lte: Bytes
  npk_in: [Bytes!]
  npk_not_in: [Bytes!]
  npk_contains: Bytes
  npk_not_contains: Bytes
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CommitmentPreimage_filter]
  or: [CommitmentPreimage_filter]
}

enum CommitmentPreimage_orderBy {
  id
  npk
  token
  token__id
  token__tokenType
  token__tokenAddress
  token__tokenSubID
  value
}

enum CommitmentType {
  ShieldCommitment
  TransactCommitment
  LegacyGeneratedCommitment
  LegacyEncryptedCommitment
}

input Commitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hashes: [Bytes!]
  hashes_not: [Bytes!]
  hashes_contains: [Bytes!]
  hashes_contains_nocase: [Bytes!]
  hashes_not_contains: [Bytes!]
  hashes_not_contains_nocase: [Bytes!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Commitment_filter]
  or: [Commitment_filter]
}

enum Commitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  commitmentType
  hashes
}

"""
8 bytes signed integer

"""
scalar Int8

type Nullifier {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  nullifier: Bytes!
}

input Nullifier_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  nullifier: Bytes
  nullifier_not: Bytes
  nullifier_gt: Bytes
  nullifier_lt: Bytes
  nullifier_gte: Bytes
  nullifier_lte: Bytes
  nullifier_in: [Bytes!]
  nullifier_not_in: [Bytes!]
  nullifier_contains: Bytes
  nullifier_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Nullifier_filter]
  or: [Nullifier_filter]
}

enum Nullifier_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  nullifier
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  commitmentPreimage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentPreimage
  commitmentPreimages(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentPreimage_orderBy
    orderDirection: OrderDirection
    where: CommitmentPreimage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentPreimage!]!
  commitmentCiphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentCiphertext
  commitmentCiphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentCiphertext_orderBy
    orderDirection: OrderDirection
    where: CommitmentCiphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentCiphertext!]!
  shieldCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShieldCommitment
  shieldCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: ShieldCommitment_orderBy
    orderDirection: OrderDirection
    where: ShieldCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ShieldCommitment!]!
  transactCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransactCommitment
  transactCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: TransactCommitment_orderBy
    orderDirection: OrderDirection
    where: TransactCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransactCommitment!]!
  unshield(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Unshield
  unshields(
    skip: Int = 0
    first: Int = 100
    orderBy: Unshield_orderBy
    orderDirection: OrderDirection
    where: Unshield_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Unshield!]!
  nullifier(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nullifier
  nullifiers(
    skip: Int = 0
    first: Int = 100
    orderBy: Nullifier_orderBy
    orderDirection: OrderDirection
    where: Nullifier_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Nullifier!]!
  railgunTransaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RailgunTransaction
  railgunTransactions(
    skip: Int = 0
    first: Int = 100
    orderBy: RailgunTransaction_orderBy
    orderDirection: OrderDirection
    where: RailgunTransaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RailgunTransaction!]!
  verificationHash(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VerificationHash
  verificationHashes(
    skip: Int = 0
    first: Int = 100
    orderBy: VerificationHash_orderBy
    orderDirection: OrderDirection
    where: VerificationHash_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VerificationHash!]!
  commitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Commitment
  commitments(
    skip: Int = 0
    first: Int = 100
    orderBy: Commitment_orderBy
    orderDirection: OrderDirection
    where: Commitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Commitment!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type RailgunTransaction {
  id: Bytes!
  blockNumber: BigInt!
  transactionHash: Bytes!
  nullifiers: [Bytes!]!
  commitments: [Bytes!]!
  boundParamsHash: Bytes!
  hasUnshield: Boolean!
  utxoTreeIn: BigInt!
  utxoTreeOut: BigInt!
  utxoBatchStartPositionOut: BigInt!
  unshieldToken: Token!
  unshieldToAddress: Bytes!
  unshieldValue: BigInt!
  blockTimestamp: BigInt!
  verificationHash: Bytes!
}

input RailgunTransaction_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  nullifiers: [Bytes!]
  nullifiers_not: [Bytes!]
  nullifiers_contains: [Bytes!]
  nullifiers_contains_nocase: [Bytes!]
  nullifiers_not_contains: [Bytes!]
  nullifiers_not_contains_nocase: [Bytes!]
  commitments: [Bytes!]
  commitments_not: [Bytes!]
  commitments_contains: [Bytes!]
  commitments_contains_nocase: [Bytes!]
  commitments_not_contains: [Bytes!]
  commitments_not_contains_nocase: [Bytes!]
  boundParamsHash: Bytes
  boundParamsHash_not: Bytes
  boundParamsHash_gt: Bytes
  boundParamsHash_lt: Bytes
  boundParamsHash_gte: Bytes
  boundParamsHash_lte: Bytes
  boundParamsHash_in: [Bytes!]
  boundParamsHash_not_in: [Bytes!]
  boundParamsHash_contains: Bytes
  boundParamsHash_not_contains: Bytes
  hasUnshield: Boolean
  hasUnshield_not: Boolean
  hasUnshield_in: [Boolean!]
  hasUnshield_not_in: [Boolean!]
  utxoTreeIn: BigInt
  utxoTreeIn_not: BigInt
  utxoTreeIn_gt: BigInt
  utxoTreeIn_lt: BigInt
  utxoTreeIn_gte: BigInt
  utxoTreeIn_lte: BigInt
  utxoTreeIn_in: [BigInt!]
  utxoTreeIn_not_in: [BigInt!]
  utxoTreeOut: BigInt
  utxoTreeOut_not: BigInt
  utxoTreeOut_gt: BigInt
  utxoTreeOut_lt: BigInt
  utxoTreeOut_gte: BigInt
  utxoTreeOut_lte: BigInt
  utxoTreeOut_in: [BigInt!]
  utxoTreeOut_not_in: [BigInt!]
  utxoBatchStartPositionOut: BigInt
  utxoBatchStartPositionOut_not: BigInt
  utxoBatchStartPositionOut_gt: BigInt
  utxoBatchStartPositionOut_lt: BigInt
  utxoBatchStartPositionOut_gte: BigInt
  utxoBatchStartPositionOut_lte: BigInt
  utxoBatchStartPositionOut_in: [BigInt!]
  utxoBatchStartPositionOut_not_in: [BigInt!]
  unshieldToken: String
  unshieldToken_not: String
  unshieldToken_gt: String
  unshieldToken_lt: String
  unshieldToken_gte: String
  unshieldToken_lte: String
  unshieldToken_in: [String!]
  unshieldToken_not_in: [String!]
  unshieldToken_contains: String
  unshieldToken_contains_nocase: String
  unshieldToken_not_contains: String
  unshieldToken_not_contains_nocase: String
  unshieldToken_starts_with: String
  unshieldToken_starts_with_nocase: String
  unshieldToken_not_starts_with: String
  unshieldToken_not_starts_with_nocase: String
  unshieldToken_ends_with: String
  unshieldToken_ends_with_nocase: String
  unshieldToken_not_ends_with: String
  unshieldToken_not_ends_with_nocase: String
  unshieldToken_: Token_filter
  unshieldToAddress: Bytes
  unshieldToAddress_not: Bytes
  unshieldToAddress_gt: Bytes
  unshieldToAddress_lt: Bytes
  unshieldToAddress_gte: Bytes
  unshieldToAddress_lte: Bytes
  unshieldToAddress_in: [Bytes!]
  unshieldToAddress_not_in: [Bytes!]
  unshieldToAddress_contains: Bytes
  unshieldToAddress_not_contains: Bytes
  unshieldValue: BigInt
  unshieldValue_not: BigInt
  unshieldValue_gt: BigInt
  unshieldValue_lt: BigInt
  unshieldValue_gte: BigInt
  unshieldValue_lte: BigInt
  unshieldValue_in: [BigInt!]
  unshieldValue_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  verificationHash: Bytes
  verificationHash_not: Bytes
  verificationHash_gt: Bytes
  verificationHash_lt: Bytes
  verificationHash_gte: Bytes
  verificationHash_lte: Bytes
  verificationHash_in: [Bytes!]
  verificationHash_not_in: [Bytes!]
  verificationHash_contains: Bytes
  verificationHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RailgunTransaction_filter]
  or: [RailgunTransaction_filter]
}

enum RailgunTransaction_orderBy {
  id
  blockNumber
  transactionHash
  nullifiers
  commitments
  boundParamsHash
  hasUnshield
  utxoTreeIn
  utxoTreeOut
  utxoBatchStartPositionOut
  unshieldToken
  unshieldToken__id
  unshieldToken__tokenType
  unshieldToken__tokenAddress
  unshieldToken__tokenSubID
  unshieldToAddress
  unshieldValue
  blockTimestamp
  verificationHash
}

type ShieldCommitment implements Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  commitmentType: CommitmentType!
  hashes: [Bytes!]!
  from: Bytes!
  treePosition: Int!
  preimage: CommitmentPreimage!
  encryptedBundle: [Bytes!]!
  shieldKey: Bytes!
  fee: BigInt!
}

input ShieldCommitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hashes: [Bytes!]
  hashes_not: [Bytes!]
  hashes_contains: [Bytes!]
  hashes_contains_nocase: [Bytes!]
  hashes_not_contains: [Bytes!]
  hashes_not_contains_nocase: [Bytes!]
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  treePosition: Int
  treePosition_not: Int
  treePosition_gt: Int
  treePosition_lt: Int
  treePosition_gte: Int
  treePosition_lte: Int
  treePosition_in: [Int!]
  treePosition_not_in: [Int!]
  preimage: String
  preimage_not: String
  preimage_gt: String
  preimage_lt: String
  preimage_gte: String
  preimage_lte: String
  preimage_in: [String!]
  preimage_not_in: [String!]
  preimage_contains: String
  preimage_contains_nocase: String
  preimage_not_contains: String
  preimage_not_contains_nocase: String
  preimage_starts_with: String
  preimage_starts_with_nocase: String
  preimage_not_starts_with: String
  preimage_not_starts_with_nocase: String
  preimage_ends_with: String
  preimage_ends_with_nocase: String
  preimage_not_ends_with: String
  preimage_not_ends_with_nocase: String
  preimage_: CommitmentPreimage_filter
  encryptedBundle: [Bytes!]
  encryptedBundle_not: [Bytes!]
  encryptedBundle_contains: [Bytes!]
  encryptedBundle_contains_nocase: [Bytes!]
  encryptedBundle_not_contains: [Bytes!]
  encryptedBundle_not_contains_nocase: [Bytes!]
  shieldKey: Bytes
  shieldKey_not: Bytes
  shieldKey_gt: Bytes
  shieldKey_lt: Bytes
  shieldKey_gte: Bytes
  shieldKey_lte: Bytes
  shieldKey_in: [Bytes!]
  shieldKey_not_in: [Bytes!]
  shieldKey_contains: Bytes
  shieldKey_not_contains: Bytes
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ShieldCommitment_filter]
  or: [ShieldCommitment_filter]
}

enum ShieldCommitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  commitmentType
  hashes
  from
  treePosition
  preimage
  preimage__id
  preimage__npk
  preimage__value
  encryptedBundle
  shieldKey
  fee
}

type Subscription {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  commitmentPreimage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentPreimage
  commitmentPreimages(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentPreimage_orderBy
    orderDirection: OrderDirection
    where: CommitmentPreimage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentPreimage!]!
  commitmentCiphertext(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CommitmentCiphertext
  commitmentCiphertexts(
    skip: Int = 0
    first: Int = 100
    orderBy: CommitmentCiphertext_orderBy
    orderDirection: OrderDirection
    where: CommitmentCiphertext_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CommitmentCiphertext!]!
  shieldCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ShieldCommitment
  shieldCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: ShieldCommitment_orderBy
    orderDirection: OrderDirection
    where: ShieldCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ShieldCommitment!]!
  transactCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransactCommitment
  transactCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: TransactCommitment_orderBy
    orderDirection: OrderDirection
    where: TransactCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransactCommitment!]!
  unshield(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Unshield
  unshields(
    skip: Int = 0
    first: Int = 100
    orderBy: Unshield_orderBy
    orderDirection: OrderDirection
    where: Unshield_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Unshield!]!
  nullifier(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nullifier
  nullifiers(
    skip: Int = 0
    first: Int = 100
    orderBy: Nullifier_orderBy
    orderDirection: OrderDirection
    where: Nullifier_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Nullifier!]!
  railgunTransaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RailgunTransaction
  railgunTransactions(
    skip: Int = 0
    first: Int = 100
    orderBy: RailgunTransaction_orderBy
    orderDirection: OrderDirection
    where: RailgunTransaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RailgunTransaction!]!
  verificationHash(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VerificationHash
  verificationHashes(
    skip: Int = 0
    first: Int = 100
    orderBy: VerificationHash_orderBy
    orderDirection: OrderDirection
    where: VerificationHash_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VerificationHash!]!
  commitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Commitment
  commitments(
    skip: Int = 0
    first: Int = 100
    orderBy: Commitment_orderBy
    orderDirection: OrderDirection
    where: Commitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Commitment!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  id: Bytes!
  tokenType: TokenType!
  tokenAddress: Bytes!
  tokenSubID: Bytes!
}

enum TokenType {
  ERC20
  ERC721
  ERC1155
}

input Token_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  tokenType: TokenType
  tokenType_not: TokenType
  tokenType_in: [TokenType!]
  tokenType_not_in: [TokenType!]
  tokenAddress: Bytes
  tokenAddress_not: Bytes
  tokenAddress_gt: Bytes
  tokenAddress_lt: Bytes
  tokenAddress_gte: Bytes
  tokenAddress_lte: Bytes
  tokenAddress_in: [Bytes!]
  tokenAddress_not_in: [Bytes!]
  tokenAddress_contains: Bytes
  tokenAddress_not_contains: Bytes
  tokenSubID: Bytes
  tokenSubID_not: Bytes
  tokenSubID_gt: Bytes
  tokenSubID_lt: Bytes
  tokenSubID_gte: Bytes
  tokenSubID_lte: Bytes
  tokenSubID_in: [Bytes!]
  tokenSubID_not_in: [Bytes!]
  tokenSubID_contains: Bytes
  tokenSubID_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  tokenType
  tokenAddress
  tokenSubID
}

type TransactCommitment implements Commitment {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  treeNumber: Int!
  commitmentType: CommitmentType!
  hashes: [Bytes!]!
  commitmentCiphertexts(skip: Int = 0, first: Int = 100, orderBy: CommitmentCiphertext_orderBy, orderDirection: OrderDirection, where: CommitmentCiphertext_filter): [CommitmentCiphertext!]!
  batchStartTreePosition: Int!
  transactIndex: Int!
  senderCiphertext: Bytes!
}

input TransactCommitment_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  treeNumber: Int
  treeNumber_not: Int
  treeNumber_gt: Int
  treeNumber_lt: Int
  treeNumber_gte: Int
  treeNumber_lte: Int
  treeNumber_in: [Int!]
  treeNumber_not_in: [Int!]
  commitmentType: CommitmentType
  commitmentType_not: CommitmentType
  commitmentType_in: [CommitmentType!]
  commitmentType_not_in: [CommitmentType!]
  hashes: [Bytes!]
  hashes_not: [Bytes!]
  hashes_contains: [Bytes!]
  hashes_contains_nocase: [Bytes!]
  hashes_not_contains: [Bytes!]
  hashes_not_contains_nocase: [Bytes!]
  commitmentCiphertexts: [String!]
  commitmentCiphertexts_not: [String!]
  commitmentCiphertexts_contains: [String!]
  commitmentCiphertexts_contains_nocase: [String!]
  commitmentCiphertexts_not_contains: [String!]
  commitmentCiphertexts_not_contains_nocase: [String!]
  commitmentCiphertexts_: CommitmentCiphertext_filter
  batchStartTreePosition: Int
  batchStartTreePosition_not: Int
  batchStartTreePosition_gt: Int
  batchStartTreePosition_lt: Int
  batchStartTreePosition_gte: Int
  batchStartTreePosition_lte: Int
  batchStartTreePosition_in: [Int!]
  batchStartTreePosition_not_in: [Int!]
  transactIndex: Int
  transactIndex_not: Int
  transactIndex_gt: Int
  transactIndex_lt: Int
  transactIndex_gte: Int
  transactIndex_lte: Int
  transactIndex_in: [Int!]
  transactIndex_not_in: [Int!]
  senderCiphertext: Bytes
  senderCiphertext_not: Bytes
  senderCiphertext_gt: Bytes
  senderCiphertext_lt: Bytes
  senderCiphertext_gte: Bytes
  senderCiphertext_lte: Bytes
  senderCiphertext_in: [Bytes!]
  senderCiphertext_not_in: [Bytes!]
  senderCiphertext_contains: Bytes
  senderCiphertext_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TransactCommitment_filter]
  or: [TransactCommitment_filter]
}

enum TransactCommitment_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  treeNumber
  commitmentType
  hashes
  commitmentCiphertexts
  batchStartTreePosition
  transactIndex
  senderCiphertext
}

type Unshield {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  to: Bytes!
  token: Token!
  value: BigInt!
  fee: BigInt!
  transactIndex: BigInt!
}

input Unshield_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  transactIndex: BigInt
  transactIndex_not: BigInt
  transactIndex_gt: BigInt
  transactIndex_lt: BigInt
  transactIndex_gte: BigInt
  transactIndex_lte: BigInt
  transactIndex_in: [BigInt!]
  transactIndex_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Unshield_filter]
  or: [Unshield_filter]
}

enum Unshield_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  to
  token
  token__id
  token__tokenType
  token__tokenAddress
  token__tokenSubID
  value
  fee
  transactIndex
}

type VerificationHash {
  id: Bytes!
  verificationHash: Bytes!
}

input VerificationHash_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  verificationHash: Bytes
  verificationHash_not: Bytes
  verificationHash_gt: Bytes
  verificationHash_lt: Bytes
  verificationHash_gte: Bytes
  verificationHash_lte: Bytes
  verificationHash_in: [Bytes!]
  verificationHash_not_in: [Bytes!]
  verificationHash_contains: Bytes
  verificationHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [VerificationHash_filter]
  or: [VerificationHash_filter]
}

enum VerificationHash_orderBy {
  id
  verificationHash
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}